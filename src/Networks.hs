{- |
Module      : $Header$
Description : Definition of 'Network' and related functions
Copyright   : (c) Denis Torgunov, 2015-2016
License     : No license

Maintainer  : dtorgunov@leafonthewind.net
Stability   : experimental
Portability : portable (depends on Gtk2Hs)

This module provides the definitions of the 'Network' data type, and all related data types and functions, such as those dealing with construction of a network, as well as those that use the network for classification.

At the moment the sign activation function is assumed by the module, and the hyperplane distance parameter is assumed to be 0.5.
-}
module Networks (
                 Network
                , emptyNet
                , isEmptyNet
                , hyperplane
                , intersectNet
                , unionNet
                , makeNetwork
                , runNetwork
                , generatePerceptron
                , applyPerceptron
                ) where

import Types

-- | A "network descpriton": this shows the topology of the network, and can be used to trace how it was
-- constructed. It represents a network on a "conceptual" level, as seen by the algorithm.
data NetworkDesc
    -- | An 'Empty' network is used as a starting point of some recursions, as well as a "catch-all" value to
    -- be returned in case of errors. It is not meant to be evaluated in input data, and doing so
    -- raises an error.
    = Empty
    -- | A 'Hyperplane' network is simply a single separating hyperplain that correctly classifies a pair of points.
    -- This hyperplane is orthogonal to a line connecting the two points. 
    | Hyperplane { plusPoint :: Input -- ^ The point classified as +1 by this hyperplane
                 , minusPoint :: Input -- ^ The point classified as -1 by this hyperplane
                 , c :: Double -- ^ A parameter that shows how close/far the hyperplane is from the +1 point
                 }
    -- | Represents a union of 2 networks
    | Union NetworkDesc NetworkDesc
    -- | Represents an intersection of 2 networks
    | Intersection NetworkDesc NetworkDesc
      deriving (Show, Eq)

-- | A "network function" is a simple function from 'Input' to 'Classification' that can be used
-- to classify any given input vector.
type NetworkFunction = Input -> Classification

-- | A network combines a network function and a description of the underlying network.
-- This is generated by the 'makeNetwork' function.
data Network = Network { f :: NetworkFunction
                       , net :: NetworkDesc
                       }

-- At the moment, we "show" a network by showing its description
instance Show Network where
    show n = show $ net n

-- | A sign activation/transfer function.
sign :: ActivationFunction
sign = signum

-- The following network combinations, for now, assume sign as the activation function

-- | Constructs an empty network
emptyNet :: Network
emptyNet = makeNetwork Empty

-- | Checks whether a network is empty
isEmptyNet :: Network -> Bool
isEmptyNet n = (net n) == Empty

-- | Constructs a network to separate two given points by a single hyperplane
hyperplane :: Input -> Input -> Double -> Network
hyperplane plusOne minusOne c = makeNetwork $ Hyperplane plusOne minusOne c

-- | Constructs an intersection of two networks
intersectNet :: Network -> Network -> Network
n1 `intersectNet` n2 = makeNetwork $ Intersection (net n1) (net n2)

-- | Constructs a union of two networks
unionNet :: Network -> Network -> Network
n1 `unionNet` n2 = makeNetwork $ Union (net n1) (net n2)

-- | A separating hyperplane function
sepFunct :: Input -- ^ Point to be classified as -1
         -> Input -- ^ Point to be classified as +1
         -> Double -- ^ The position parameter
         -> (Input -> Double) -- ^ Returns a function that can then be passed to the activation function
sepFunct u v c = \x -> (x <.> w) - l
    where
      w = zipWith (-) v u
      l = c * (squaredNorm w) - (squaredNorm u) + (u <.> v)

-- | Generate a network function based on the network description
networkFunction :: NetworkDesc -> NetworkFunction
networkFunction Empty = \_ -> 0
networkFunction (Hyperplane plusOne minusOne c) = sign . sepFunct minusOne plusOne c
networkFunction (Union n1 n2) = \xs -> sign $ (n1' xs) + (n2' xs) + 0.5
    where
      n1' = networkFunction n1
      n2' = networkFunction n2
networkFunction (Intersection n1 n2) = \xs -> sign $ (n1' xs) + (n2' xs) - 0.5
    where
      n1' = networkFunction n1
      n2' = networkFunction n2

-- | Create a network based on the description of its topology
makeNetwork :: NetworkDesc -> Network
makeNetwork n = Network (networkFunction n) n

-- | Classify an 'Input' vector by the given 'Network'
runNetwork :: Network -> Input -> Classification
runNetwork n xs = (f n) xs

squaredNorm = sum . map (^2)
a <.> b = sum $ zipWith (*) a b

generatePerceptron :: Network -> Weights
generatePerceptron = generatePerceptron' . net
          
generatePerceptron' :: NetworkDesc -> Weights
generatePerceptron' Empty = undefined
generatePerceptron' (Union _ _) = undefined
generatePerceptron' (Intersection _ _) = undefined
generatePerceptron' (Hyperplane plusOne minusOne c) = ws ++ [b]
    where
      ws = zipWith (-) plusOne minusOne
      b = (squaredNorm minusOne) - (minusOne <.> plusOne) - c * (squaredNorm ws)

applyPerceptron :: Input -> Weights -> Classification
applyPerceptron x w = sign $ (x ++ [1]) <.> w

-- A property to test: for any given a, b, c and a list of doubles xs of the same size:
-- (runNetwork (hyperplane a b c) x) == (applyPerceptron x (hyperplane a b c))
